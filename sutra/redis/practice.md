## 应用
- 缓存
- 分布式锁
- 简答限流/秒杀/漏斗限流 cell 4.0
- 消息队列(list)/延时队列(zset)
- bitmap/geo(zset|3.2)/hyperloglog
- 布隆过滤(bitmap|4.0)
- 时间序列数据库

## 缓存
- 收益：加速读写 / 降低后端负载（减少访问量和复杂计算）
- 成本：数据不一致 / 代码维护 / 运维
- 场景：复杂计算 / 加速请求响应
- 更新策略
    - LRU/LFU/FIFO 算法剔除，一致性最差，无需维护
    - 超时剔除，一致性差，维护成本低
    - 主动更新，一致性好，维护成本高
- 缓存粒度，在内存带宽占用和代码维护成本之间权衡
- 穿透：对于不存在的数据，缓存和存储都不命中，每次都会到存储层查询
    - 解决：缓存空对象/布隆过滤器拦截
- 击穿（热点key重建）：并发请求过期key时，多个请求落到存储层
    - 解决：使用互斥锁，只允许一个请求落到存储层 / 缓存不过期，刷新缓存，存在数据不一致窗口
- 雪崩：缓存停止服务或大量key同时过期时，请求全部涌向后端存储层
    - 解决：高可用 / 后端限流并降级
- 无底洞：集群中，一次批量查询会请求多个节点，节点越多，请求越多
    - 解决：get / mget 串行 / mget 并行 / hash_tag
- 污染：
- 数据不一致
    - 先更新数据库，后更新缓存时，缓存有延迟，或有可能未得到更新
    - 先删缓存，再更新数据库，缓存有可能被旧数据回源
- 热点key
    - 可从 客户端/代理端/服务端/抓包 统计分析
    - 解决：拆分复杂数据结构 / 迁移热点key到单独节点 / 本地缓存+更新通知机制
- bigkey
    - 字符串类型超过10k，非字符串类型个数过多
    - 危害：集群中内存使用不均 / 查询/删除超时堵塞 / 网络堵塞 / 写时复制占用内存/ 切片迁移耗时 / rehash 占内存
    - scan+debug object/type+len/hlen/llen/scard/zcard 计算
    - 删除：string直接删除 / 其他类型分批删除 / 4.0 lazy delete free
- string类型存储小数据时浪费内存，可改为hash存储
- 工作
    - string/hash/zset/set
    - 文章等详情数据，使用 string 类型存储 json 序列化数据
    - 留言等列表数据，使用 zset 类型存储带有排序权重可分页数据
    - 专栏反现热榜，使用 zset 类型存储
    - 收藏人数/收藏状态等，使用 string/hash 类型存储
    - 根据订阅用户求专栏相似度，需要大集合求交集，使用 set 类型存储

## 分布式锁
- setnx + expire / set ex|px nx
- 超时问题：进程1执行超时导致锁过期，锁被进程2获取后，又被进程1释放，导致进程2/3同时拿到锁
- 可重入性：支持多次加锁，通过给锁增加计数实现
- 高可用：redlock算法，通过多节点共识加锁实现

## 限流
- incr+expire 限流
- zset 限流
- 漏斗限流 redis-cell 4.0
- 工作
    - 限制用户每天提现次数
    - 过滤一段时间内的重复学习数据

## 秒杀
- 工作
    - 使用 decr 限制并发写场景，如抢文章试读名额

## 消息队列
- blpop/brpush 避免空轮询
- 注意连接断开后要自动重连

## 延时队列
- 锁冲突的解决方案之一
- 使用 zset 实现，score 存储执行时间，使用 lua 脚本保证出对操作原子


## 布隆过滤器

## 时间序列数据库